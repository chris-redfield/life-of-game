<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life of Game - Biology Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            font-family: 'Rajdhani', sans-serif;
            color: #c0e0d0;
            overflow: hidden;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Main simulation area */
        .simulation-area {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, #1a4a4a 0%, #0f3535 40%, #0a2828 70%, #061e1e 100%);
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Ambient particles overlay */
        .ambient-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(120, 200, 200, 0.08), transparent),
                radial-gradient(1px 1px at 40% 70%, rgba(100, 180, 170, 0.06), transparent),
                radial-gradient(2px 2px at 60% 20%, rgba(140, 210, 200, 0.07), transparent),
                radial-gradient(1px 1px at 80% 60%, rgba(90, 170, 160, 0.05), transparent),
                radial-gradient(3px 3px at 50% 50%, rgba(80, 160, 150, 0.04), transparent);
            background-size: 250px 250px, 180px 180px, 220px 220px, 200px 200px, 300px 300px;
            animation: drift 80s linear infinite;
        }

        @keyframes drift {
            0% { background-position: 0 0, 0 0, 0 0, 0 0; }
            100% { background-position: 200px 100px, -150px 75px, 180px -90px, -160px 80px; }
        }

        /* Side panel */
        .side-panel {
            width: 320px;
            background: linear-gradient(180deg, #0c1210 0%, #080d0b 100%);
            border-left: 1px solid rgba(100, 200, 150, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #40e0a0;
            text-transform: uppercase;
            letter-spacing: 3px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(100, 200, 150, 0.3);
            text-shadow: 0 0 20px rgba(64, 224, 160, 0.5);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-box {
            background: rgba(20, 40, 30, 0.6);
            border: 1px solid rgba(100, 200, 150, 0.15);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #60ffc0;
            text-shadow: 0 0 10px rgba(96, 255, 192, 0.4);
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(192, 224, 208, 0.6);
            margin-top: 4px;
        }

        .section {
            background: rgba(15, 30, 22, 0.5);
            border: 1px solid rgba(100, 200, 150, 0.1);
            border-radius: 10px;
            padding: 16px;
        }

        .section-title {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(192, 224, 208, 0.8);
            margin-bottom: 12px;
        }

        .food-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .food-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .food-icon.oxygen { background: rgba(100, 180, 255, 0.3); border: 1px solid rgba(100, 180, 255, 0.6); }
        .food-icon.glucose { background: rgba(255, 200, 100, 0.3); border: 1px solid rgba(255, 200, 100, 0.6); }
        .food-icon.amino { background: rgba(255, 100, 180, 0.3); border: 1px solid rgba(255, 100, 180, 0.6); }

        .food-bar-track {
            flex: 1;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
        }

        .food-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .food-bar-fill.oxygen { background: linear-gradient(90deg, #4080ff, #80c0ff); }
        .food-bar-fill.glucose { background: linear-gradient(90deg, #ffc040, #ffe080); }
        .food-bar-fill.amino { background: linear-gradient(90deg, #ff60b0, #ff90d0); }

        .food-count {
            width: 40px;
            text-align: right;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(180deg, rgba(64, 224, 160, 0.2) 0%, rgba(64, 224, 160, 0.05) 100%);
            border: 1px solid rgba(64, 224, 160, 0.4);
            color: #40e0a0;
            padding: 12px 16px;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: linear-gradient(180deg, rgba(64, 224, 160, 0.3) 0%, rgba(64, 224, 160, 0.1) 100%);
            box-shadow: 0 0 20px rgba(64, 224, 160, 0.2);
        }

        .btn.danger {
            border-color: rgba(255, 100, 100, 0.4);
            color: #ff8080;
        }

        .btn.danger:hover {
            background: linear-gradient(180deg, rgba(255, 100, 100, 0.3) 0%, rgba(255, 100, 100, 0.1) 100%);
        }

        /* Slider controls */
        .slider-group {
            margin-bottom: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 6px;
            color: rgba(192, 224, 208, 0.7);
        }

        .slider-value {
            font-family: 'Orbitron', sans-serif;
            color: #60ffc0;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #40e0a0;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(64, 224, 160, 0.5);
        }

        /* Selected organism info */
        .organism-info {
            display: none;
        }

        .organism-info.active {
            display: block;
        }

        .dna-display {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .chromosome {
            flex: 1;
            min-width: 50px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-family: 'Orbitron', sans-serif;
        }

        .trait-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .trait-name {
            color: rgba(192, 224, 208, 0.7);
        }

        .trait-value {
            font-family: 'Orbitron', sans-serif;
            color: #60ffc0;
        }

        /* Generation history */
        .generation-bar {
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Time display */
        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(192, 224, 208, 0.5);
            text-align: center;
            padding: 10px;
            border-top: 1px solid rgba(100, 200, 150, 0.1);
            margin-top: auto;
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(10, 20, 15, 0.95);
            border: 1px solid rgba(100, 200, 150, 0.3);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .tooltip.visible {
            display: block;
        }

        /* Speed indicator */
        .speed-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-top: 10px;
        }

        .speed-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid rgba(100, 200, 150, 0.3);
            background: transparent;
            color: #40e0a0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
        }

        .speed-btn:hover {
            background: rgba(64, 224, 160, 0.2);
        }

        .speed-btn.active {
            background: rgba(64, 224, 160, 0.3);
            border-color: #40e0a0;
        }

        /* Stats Overlay */
        .stats-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(8, 25, 22, 0.95);
            z-index: 100;
            display: none;
            overflow-y: auto;
            padding: 30px;
        }

        .stats-overlay.active {
            display: block;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(100, 200, 150, 0.3);
        }

        .stats-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #40e0a0;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(64, 224, 160, 0.5);
        }

        .close-stats {
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.4);
            color: #ff8080;
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-stats:hover {
            background: rgba(255, 100, 100, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .stats-card {
            background: rgba(15, 40, 35, 0.6);
            border: 1px solid rgba(100, 200, 150, 0.2);
            border-radius: 12px;
            padding: 20px;
        }

        .stats-card.full-width {
            grid-column: 1 / -1;
        }

        .stats-card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #40e0a0;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 150, 0.15);
        }

        .chart-container {
            height: 150px;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }

        .chart-container.tall {
            height: 200px;
        }

        .chart-container.medium-tall {
            height: 240px;
        }

        .top-organisms-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .top-organism-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .organism-rank {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #40e0a0;
            width: 30px;
        }

        .organism-color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .organism-details {
            flex: 1;
        }

        .organism-stat-name {
            font-size: 13px;
            color: rgba(192, 224, 208, 0.8);
            margin-bottom: 3px;
        }

        .organism-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: #60ffc0;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-stat {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .summary-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: #60ffc0;
            text-shadow: 0 0 15px rgba(96, 255, 192, 0.4);
        }

        .summary-stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(192, 224, 208, 0.6);
            margin-top: 5px;
        }

        .distribution-bar {
            display: flex;
            height: 30px;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .distribution-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-family: 'Orbitron', sans-serif;
            color: rgba(0, 0, 0, 0.7);
            transition: all 0.3s;
        }

        .distribution-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
        }

        .distribution-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .distribution-legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .no-data-message {
            text-align: center;
            padding: 30px;
            color: rgba(192, 224, 208, 0.5);
            font-style: italic;
        }

        .trait-avg-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .trait-avg-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 8px;
        }

        .trait-avg-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .trait-avg-name {
            color: rgba(192, 224, 208, 0.8);
        }

        .trait-avg-value {
            font-family: 'Orbitron', sans-serif;
            color: #60ffc0;
        }

        .trait-avg-bar-bg {
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        .trait-avg-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="simulation-area">
            <canvas id="canvas"></canvas>
            <div class="ambient-overlay"></div>
            <div class="tooltip" id="tooltip"></div>
            
            <!-- Stats Overlay -->
            <div class="stats-overlay" id="statsOverlay">
                <div class="stats-header">
                    <h2 class="stats-title">üìä Statistics Report</h2>
                    <button class="close-stats" id="closeStats">‚Üê Return to Simulation</button>
                </div>
                
                <div class="summary-stats">
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="statTotalBorn">0</div>
                        <div class="summary-stat-label">Total Born</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="statTotalDied">0</div>
                        <div class="summary-stat-label">Total Died</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="statCurrentPop">0</div>
                        <div class="summary-stat-label">Current Pop.</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="statPeakPop">0</div>
                        <div class="summary-stat-label">Peak Pop.</div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stats-card full-width">
                        <div class="stats-card-title">üìà Population Over Time</div>
                        <div class="chart-container tall">
                            <canvas id="populationChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="stats-card full-width">
                        <div class="stats-card-title">üíÄ Births & Deaths Over Time</div>
                        <div class="chart-container tall">
                            <canvas id="birthDeathChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">ü¶† Movement Type Distribution</div>
                        <div id="movementDistribution"></div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">üçΩÔ∏è Metabolism Distribution</div>
                        <div id="metabolismDistribution"></div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">üèÜ Longest Lived Organisms</div>
                        <div class="top-organisms-list" id="longestLivedList"></div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">üë∂ Most Offspring</div>
                        <div class="top-organisms-list" id="mostOffspringList"></div>
                    </div>
                    
                    <div class="stats-card full-width">
                        <div class="stats-card-title">üìä Average Traits Over Generations</div>
                        <div class="chart-container">
                            <canvas id="traitsChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">üß¨ Generation Distribution</div>
                        <div class="chart-container medium-tall">
                            <canvas id="generationChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="stats-card">
                        <div class="stats-card-title">‚ö° Size vs Speed</div>
                        <div class="chart-container medium-tall">
                            <canvas id="sizeSpeedChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="stats-card full-width">
                        <div class="stats-card-title">üî¨ Trait Averages Comparison</div>
                        <div id="traitAverages"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="side-panel">
            <h1 class="panel-title">Life of Game</h1>
            
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="population">0</div>
                    <div class="stat-label">Organisms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="generation">1</div>
                    <div class="stat-label">Generation</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="births">0</div>
                    <div class="stat-label">Births</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="deaths">0</div>
                    <div class="stat-label">Deaths</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Food Supply</div>
                <div class="food-bar">
                    <div class="food-icon oxygen">O‚ÇÇ</div>
                    <div class="food-bar-track">
                        <div class="food-bar-fill oxygen" id="oxygenBar" style="width: 100%"></div>
                    </div>
                    <div class="food-count" id="oxygenCount">0</div>
                </div>
                <div class="food-bar">
                    <div class="food-icon glucose">G</div>
                    <div class="food-bar-track">
                        <div class="food-bar-fill glucose" id="glucoseBar" style="width: 50%"></div>
                    </div>
                    <div class="food-count" id="glucoseCount">0</div>
                </div>
                <div class="food-bar">
                    <div class="food-icon amino">A</div>
                    <div class="food-bar-track">
                        <div class="food-bar-fill amino" id="aminoBar" style="width: 20%"></div>
                    </div>
                    <div class="food-count" id="aminoCount">0</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Simulation Settings</div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Food Spawn Rate</span>
                        <span class="slider-value" id="foodRateValue">1.0x</span>
                    </div>
                    <input type="range" id="foodRate" min="0.1" max="3" step="0.1" value="1">
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Mutation Rate</span>
                        <span class="slider-value" id="mutationRateValue">8%</span>
                    </div>
                    <input type="range" id="mutationRate" min="1" max="30" step="1" value="8">
                </div>
                
                <div class="speed-indicator">
                    <button class="speed-btn" id="pauseBtn">‚è∏</button>
                    <button class="speed-btn active" id="speed1">1x</button>
                    <button class="speed-btn" id="speed2">2x</button>
                    <button class="speed-btn" id="speed3">4x</button>
                </div>
            </div>

            <div class="section organism-info" id="organismInfo">
                <div class="section-title">Selected Organism</div>
                <div class="dna-display" id="dnaDisplay"></div>
                <div class="trait-list" id="traitList"></div>
            </div>

            <div class="section">
                <div class="section-title">Species Distribution</div>
                <div class="generation-bar" id="speciesBar"></div>
                <div class="legend" id="speciesLegend"></div>
            </div>

            <div class="controls">
                <button class="btn" id="showStats">üìä View Statistics</button>
                <button class="btn" id="addOrganisms">+ Add 10 Organisms</button>
                <button class="btn" id="addFood">+ Add Food Burst</button>
                <button class="btn danger" id="reset">Reset Simulation</button>
            </div>

            <div class="time-display">
                Time: <span id="timeElapsed">0:00</span>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // LIFE OF GAME - BIOLOGY SIMULATION
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============================================
        // DNA & GENETICS SYSTEM
        // ============================================

        // DNA Structure: 5 chromosomes, each with gene values
        // Gene values are 0-255, mapped to traits

        const CHROMOSOME_FUNCTIONS = {
            0: 'physical',      // Size, membrane, shape
            1: 'movement',      // Movement type, speed
            2: 'metabolism',    // What they eat, efficiency  
            3: 'reproduction',  // Rate, mutation tendency
            4: 'sensory'        // Detection range, behavior
        };

        const MOVEMENT_TYPES = ['none', 'cilia', 'flagellum', 'pseudopod'];
        const METABOLISM_TYPES = ['oxygen', 'glucose', 'amino', 'dual'];

        class DNA {
            constructor(chromosomes = null) {
                if (chromosomes) {
                    this.chromosomes = chromosomes.map(c => [...c]);
                } else {
                    // Initialize random DNA
                    this.chromosomes = [];
                    for (let i = 0; i < 5; i++) {
                        const genes = [];
                        for (let j = 0; j < 100; j++) {
                            genes.push(Math.floor(Math.random() * 256));
                        }
                        this.chromosomes.push(genes);
                    }
                }
            }

            // Get average value of a gene range (using 2 genes for balance between stability and mutation sensitivity)
            getGeneRange(chromosome, start, end) {
                // Use 2 key genes from the range - middle ground between 1 (too jumpy) and 3+ (too stable)
                const mid = Math.floor((start + end) / 2);
                const gene1 = this.chromosomes[chromosome][start];
                const gene2 = this.chromosomes[chromosome][mid];
                return (gene1 + gene2) / 2;
            }

            // Decode traits from DNA
            decodeTraits() {
                // Calculate how many food types this organism can eat (for specialist bonus)
                const canOxygen = this.chromosomes[2][0] > 100;
                const canGlucose = this.chromosomes[2][25] > 128;
                const canAmino = this.chromosomes[2][50] > 180;
                const foodTypesCount = (canOxygen ? 1 : 0) + (canGlucose ? 1 : 0) + (canAmino ? 1 : 0);
                
                // Specialist bonus: eating fewer food types = more efficient at those
                // 1 food type = 1.8x, 2 food types = 1.3x, 3 food types = 1.0x
                const specialistBonus = foodTypesCount === 1 ? 1.8 : (foodTypesCount === 2 ? 1.3 : 1.0);
                
                // Get base size (wider range: 5-40 instead of 8-25)
                const baseSize = this.mapRange(this.getGeneRange(0, 0, 20), 0, 255, 5, 40);
                
                // Get genetic speed (wider range: 0.1-4.0 instead of 0.2-2)
                const geneticSpeed = this.mapRange(this.getGeneRange(1, 25, 50), 0, 255, 0.1, 4.0);
                
                // Large size = slower (size penalty on speed)
                // At size 5: 1.0x speed, at size 40: 0.4x speed
                const sizeSpeedPenalty = this.mapRange(baseSize, 5, 40, 1.0, 0.4);
                
                return {
                    // Physical (Chromosome 0) - wider ranges
                    size: baseSize,
                    membraneThickness: this.mapRange(this.getGeneRange(0, 20, 40), 0, 255, 0.5, 4),
                    elasticity: this.mapRange(this.getGeneRange(0, 40, 60), 0, 255, 0.2, 1.2),
                    
                    // Movement (Chromosome 1) - speed affected by size
                    movementType: MOVEMENT_TYPES[Math.floor(this.chromosomes[1][0] / 64)],
                    geneticSpeed: geneticSpeed,  // Raw genetic speed
                    baseSpeed: geneticSpeed * sizeSpeedPenalty,  // Actual speed after size penalty
                    turnRate: this.mapRange(this.getGeneRange(1, 50, 75), 0, 255, 0.01, 0.25),
                    movementEfficiency: this.mapRange(this.getGeneRange(1, 75, 100), 0, 255, 0.3, 2.0),
                    
                    // Metabolism (Chromosome 2)
                    primaryFood: this.getPrimaryFood(),
                    canEatOxygen: canOxygen,
                    canEatGlucose: canGlucose,
                    canEatAmino: canAmino,
                    foodTypesCount: foodTypesCount,
                    specialistBonus: specialistBonus,
                    metabolicRate: this.mapRange(this.getGeneRange(2, 75, 100), 0, 255, 0.2, 2.0),
                    
                    // Reproduction (Chromosome 3) - wider ranges
                    reproductionThreshold: this.mapRange(this.getGeneRange(3, 0, 33), 0, 255, 40, 200),
                    offspringEnergy: this.mapRange(this.getGeneRange(3, 33, 66), 0, 255, 0.25, 0.55),
                    mutationTendency: this.mapRange(this.getGeneRange(3, 66, 100), 0, 255, 0.01, 0.20),
                    
                    // Sensory (Chromosome 4) - much wider range
                    sensorRange: this.mapRange(this.getGeneRange(4, 0, 33), 0, 255, 15, 250),
                    foodPreference: this.mapRange(this.getGeneRange(4, 33, 66), 0, 255, 0, 1),
                    flockingTendency: this.mapRange(this.getGeneRange(4, 66, 100), 0, 255, 0, 0.8),

                    // Computed color from DNA
                    color: this.computeColor()
                };
            }

            getPrimaryFood() {
                // Use single genes for clearer differentiation
                const o = this.chromosomes[2][0];
                const g = this.chromosomes[2][25];
                const a = this.chromosomes[2][50];
                
                if (o >= g && o >= a) return 'oxygen';
                if (g >= o && g >= a) return 'glucose';
                return 'amino';
            }

            computeColor() {
                // Color derived from key genes across different chromosomes for diversity
                const r = this.chromosomes[0][10];  // From physical
                const g = this.chromosomes[1][10];  // From movement  
                const b = this.chromosomes[2][10];  // From metabolism
                
                // Normalize to brighter colors
                const max = Math.max(r, g, b, 1);
                const factor = 180 / max;
                
                return {
                    r: Math.min(255, Math.floor(r * factor) + 60),
                    g: Math.min(255, Math.floor(g * factor) + 60),
                    b: Math.min(255, Math.floor(b * factor) + 60)
                };
            }

            mapRange(value, inMin, inMax, outMin, outMax) {
                return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
            }

            // Reproduce with mutation
            reproduce(mutationRate) {
                const newChromosomes = this.chromosomes.map(chromosome => {
                    return chromosome.map(gene => {
                        if (Math.random() < mutationRate) {
                            // 10% chance of "jump mutation" - completely new value
                            if (Math.random() < 0.1) {
                                return Math.floor(Math.random() * 256);
                            }
                            // Normal mutation: larger change (¬±50 instead of ¬±15)
                            const change = Math.floor(Math.random() * 100) - 50;
                            return Math.max(0, Math.min(255, gene + change));
                        }
                        return gene;
                    });
                });
                return new DNA(newChromosomes);
            }

            // Get species signature (for grouping similar organisms)
            getSpeciesSignature() {
                // Use metabolism genes as species identifier
                const sig = [];
                for (let i = 0; i < 5; i++) {
                    sig.push(Math.floor(this.chromosomes[2][i * 20] / 64));
                }
                return sig.join('-');
            }
        }

        // ============================================
        // ORGANISM CLASS
        // ============================================

        class Organism {
            constructor(x, y, dna = null) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.dna = dna || new DNA();
                this.traits = this.dna.decodeTraits();
                
                this.energy = 50 + Math.random() * 30;
                this.age = 0;
                this.generation = 1;
                
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.targetAngle = Math.random() * Math.PI * 2;
                
                this.size = this.traits.size;
                this.pulsePhase = Math.random() * Math.PI * 2;
                
                this.selected = false;
                this.dead = false;
                
                // Stats tracking
                this.offspringCount = 0;
                this.foodEaten = 0;
                this.maxEnergy = this.energy;
            }

            update(deltaTime, foods, organisms) {
                if (this.dead) return;
                
                this.age += deltaTime;
                this.pulsePhase += deltaTime * 3;
                
                // === ENERGY COSTS WITH TRADE-OFFS ===
                
                // Base cost: metabolism √ó size (bigger = hungrier)
                let energyCost = 0.015 * this.traits.metabolicRate * (this.size / 20);
                
                // Sensor drain: good sensors cost energy (small but exists)
                // At sensorRange 15: ~0, at sensorRange 250: ~0.008
                energyCost += 0.00004 * this.traits.sensorRange;
                
                // Movement cost: speed √ó 1.5 multiplier (fast is expensive!)
                if (this.traits.movementType !== 'none') {
                    this.move(foods, organisms);
                    // Speed costs 1.5x energy
                    energyCost += 0.012 * this.traits.baseSpeed * 1.5;
                } else {
                    // Passive drift - very cheap
                    this.x += (Math.random() - 0.5) * 0.3;
                    this.y += (Math.random() - 0.5) * 0.3;
                }
                
                this.energy -= energyCost;
                
                // Boundary wrapping
                if (this.x < -this.size) this.x = canvas.width + this.size;
                if (this.x > canvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = canvas.height + this.size;
                if (this.y > canvas.height + this.size) this.y = -this.size;
                
                // Death check
                if (this.energy <= 0) {
                    this.dead = true;
                    stats.deaths++;
                }
            }

            move(foods, organisms) {
                // Find nearest food
                let nearestFood = null;
                let nearestDist = this.traits.sensorRange;
                
                for (const food of foods) {
                    if (!this.canEat(food.type)) continue;
                    
                    const dist = this.distanceTo(food);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestFood = food;
                    }
                }
                
                // Move towards food or wander
                if (nearestFood) {
                    const dx = nearestFood.x - this.x;
                    const dy = nearestFood.y - this.y;
                    this.targetAngle = Math.atan2(dy, dx);
                } else {
                    // Random wandering with momentum
                    if (Math.random() < 0.02) {
                        this.targetAngle += (Math.random() - 0.5) * Math.PI;
                    }
                }
                
                // Smooth turning
                const currentAngle = Math.atan2(this.vy, this.vx);
                let angleDiff = this.targetAngle - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                let newAngle = currentAngle + angleDiff * this.traits.turnRate;
                
                // Apply movement based on type
                let speed = this.traits.baseSpeed;
                
                if (this.traits.movementType === 'flagellum') {
                    // Fast but less maneuverable
                    speed *= 1.1;
                    newAngle = currentAngle + angleDiff * this.traits.turnRate * 0.9;
                } else if (this.traits.movementType === 'cilia') {
                    // Smooth movement
                    speed *= 1.0;
                } else if (this.traits.movementType === 'pseudopod') {
                    // Slow but efficient
                    speed *= 0.7;
                }
                
                this.vx = Math.cos(newAngle) * speed;
                this.vy = Math.sin(newAngle) * speed;
                
                this.x += this.vx;
                this.y += this.vy;
            }

            canEat(foodType) {
                if (foodType === 'oxygen') return this.traits.canEatOxygen;
                if (foodType === 'glucose') return this.traits.canEatGlucose;
                if (foodType === 'amino') return this.traits.canEatAmino;
                return false;
            }

            tryEat(food) {
                if (!this.canEat(food.type)) return false;
                
                const dist = this.distanceTo(food);
                if (dist < this.size + food.size) {
                    // Energy gained depends on food type and metabolism
                    let energyGain = food.energy;
                    
                    // Primary food bonus
                    if (food.type === this.traits.primaryFood) {
                        energyGain *= 1.4;
                    }
                    
                    // SPECIALIST BONUS: fewer food types = more efficient
                    // 1 type: 1.8x, 2 types: 1.3x, 3 types: 1.0x
                    energyGain *= this.traits.specialistBonus;
                    
                    energyGain *= this.traits.metabolicRate;
                    this.energy += energyGain;
                    this.foodEaten++;
                    this.maxEnergy = Math.max(this.maxEnergy, this.energy);
                    
                    return true;
                }
                return false;
            }

            canReproduce() {
                return this.energy >= this.traits.reproductionThreshold;
            }

            reproduce(globalMutationRate) {
                if (!this.canReproduce()) return null;
                
                // Mutation rate = base rate + organism's tendency (not multiplied!)
                // This ensures mutations actually happen
                const mutationRate = globalMutationRate + this.traits.mutationTendency;
                const childDNA = this.dna.reproduce(mutationRate);
                
                // Split energy
                const childEnergy = this.energy * this.traits.offspringEnergy;
                this.energy -= childEnergy;
                
                // Spawn nearby
                const angle = Math.random() * Math.PI * 2;
                const dist = this.size * 2;
                
                const child = new Organism(
                    this.x + Math.cos(angle) * dist,
                    this.y + Math.sin(angle) * dist,
                    childDNA
                );
                child.energy = childEnergy;
                child.generation = this.generation + 1;
                
                // Track offspring
                this.offspringCount++;
                
                stats.births++;
                stats.maxGeneration = Math.max(stats.maxGeneration, child.generation);
                
                return child;
            }

            distanceTo(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            draw(ctx) {
                const pulse = Math.sin(this.pulsePhase) * 0.1 + 1;
                const drawSize = this.size * pulse;
                const color = this.traits.color;
                
                // Glow effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, drawSize * 2
                );
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawSize * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Cell body
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`;
                ctx.fill();
                
                // Membrane
                ctx.lineWidth = this.traits.membraneThickness;
                ctx.strokeStyle = `rgba(${Math.min(255, color.r + 30)}, ${Math.min(255, color.g + 30)}, ${Math.min(255, color.b + 30)}, 0.9)`;
                ctx.stroke();
                
                // Nucleus
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawSize * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color.r * 0.6}, ${color.g * 0.6}, ${color.b * 0.6}, 0.9)`;
                ctx.fill();
                
                // Movement appendages
                this.drawMovementType(ctx, drawSize, color);
                
                // Selection indicator
                if (this.selected) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, drawSize + 5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#40e0a0';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Energy bar
                const barWidth = drawSize * 2;
                const barHeight = 3;
                const barY = this.y + drawSize + 8;
                const energyRatio = Math.min(1, this.energy / this.traits.reproductionThreshold);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                const energyColor = energyRatio > 0.5 ? '#40e0a0' : (energyRatio > 0.25 ? '#e0c040' : '#e04040');
                ctx.fillStyle = energyColor;
                ctx.fillRect(this.x - barWidth/2, barY, barWidth * energyRatio, barHeight);
            }

            drawMovementType(ctx, size, color) {
                const angle = Math.atan2(this.vy, this.vx);
                
                if (this.traits.movementType === 'flagellum') {
                    // Single tail
                    ctx.beginPath();
                    ctx.moveTo(
                        this.x - Math.cos(angle) * size,
                        this.y - Math.sin(angle) * size
                    );
                    
                    const wave = Math.sin(this.pulsePhase * 3) * 5;
                    ctx.bezierCurveTo(
                        this.x - Math.cos(angle) * size * 1.5 + Math.cos(angle + Math.PI/2) * wave,
                        this.y - Math.sin(angle) * size * 1.5 + Math.sin(angle + Math.PI/2) * wave,
                        this.x - Math.cos(angle) * size * 2 - Math.cos(angle + Math.PI/2) * wave,
                        this.y - Math.sin(angle) * size * 2 - Math.sin(angle + Math.PI/2) * wave,
                        this.x - Math.cos(angle) * size * 2.5,
                        this.y - Math.sin(angle) * size * 2.5
                    );
                    
                    ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                } else if (this.traits.movementType === 'cilia') {
                    // Multiple small hairs
                    const numCilia = 12;
                    for (let i = 0; i < numCilia; i++) {
                        const ciliaAngle = (i / numCilia) * Math.PI * 2;
                        const wave = Math.sin(this.pulsePhase * 5 + i) * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            this.x + Math.cos(ciliaAngle) * size,
                            this.y + Math.sin(ciliaAngle) * size
                        );
                        ctx.lineTo(
                            this.x + Math.cos(ciliaAngle + wave) * (size + 6),
                            this.y + Math.sin(ciliaAngle + wave) * (size + 6)
                        );
                        ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                } else if (this.traits.movementType === 'pseudopod') {
                    // Amoeba-like extensions
                    const numPods = 4;
                    for (let i = 0; i < numPods; i++) {
                        const podAngle = (i / numPods) * Math.PI * 2 + this.pulsePhase * 0.2;
                        const podLength = size * (0.5 + Math.sin(this.pulsePhase + i * 2) * 0.3);
                        
                        ctx.beginPath();
                        ctx.ellipse(
                            this.x + Math.cos(podAngle) * size * 0.8,
                            this.y + Math.sin(podAngle) * size * 0.8,
                            podLength,
                            podLength * 0.5,
                            podAngle,
                            0, Math.PI * 2
                        );
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;
                        ctx.fill();
                    }
                }
            }
        }

        // ============================================
        // FOOD PARTICLES
        // ============================================

        class Food {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.age = 0;
                
                // Properties based on type
                if (type === 'oxygen') {
                    this.size = 4;
                    this.energy = 5;
                    this.color = { r: 100, g: 180, b: 255 };
                    this.lifespan = 600;
                } else if (type === 'glucose') {
                    this.size = 6;
                    this.energy = 15;
                    this.color = { r: 255, g: 200, b: 100 };
                    this.lifespan = 400;
                } else if (type === 'amino') {
                    this.size = 8;
                    this.energy = 30;
                    this.color = { r: 255, g: 100, b: 180 };
                    this.lifespan = 300;
                }
                
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.consumed = false;
            }

            update() {
                this.age++;
                
                // Gentle drift
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary wrapping
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
                
                // Decay
                if (this.age > this.lifespan) {
                    this.consumed = true;
                }
            }

            draw(ctx) {
                const alpha = Math.max(0.3, 1 - this.age / this.lifespan);
                const pulse = Math.sin(this.age * 0.1) * 0.2 + 1;
                
                // Glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2 * pulse
                );
                gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                ctx.fill();
            }
        }

        // ============================================
        // SIMULATION STATE
        // ============================================

        let organisms = [];
        let foods = [];
        let stats = {
            births: 0,
            deaths: 0,
            maxGeneration: 1,
            timeElapsed: 0,
            peakPopulation: 0,
            // History tracking (recorded every ~2 seconds of game time)
            history: {
                population: [],
                births: [],
                deaths: [],
                timestamps: [],
                avgSpeed: [],
                avgSize: []
            },
            lastHistoryTime: 0,
            // Archive of dead organisms for analysis
            deadArchive: [],
            maxArchiveSize: 100
        };

        let settings = {
            foodSpawnRate: 1,
            mutationRate: 0.08,
            speed: 1,
            paused: false
        };

        let selectedOrganism = null;
        let showingStats = false;

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            // Create initial organisms
            for (let i = 0; i < 5; i++) {
                organisms.push(new Organism(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
            
            // Create initial food
            spawnFood('oxygen', 100);
            spawnFood('glucose', 50);
            spawnFood('amino', 20);
        }

        function spawnFood(type, count) {
            for (let i = 0; i < count; i++) {
                foods.push(new Food(
                    type,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================

        let lastTime = 0;
        let foodSpawnTimer = 0;

        function gameLoop(timestamp) {
            const deltaTime = Math.min(50, timestamp - lastTime) / 16.67; // Normalize to ~60fps
            lastTime = timestamp;
            
            if (!settings.paused) {
                for (let i = 0; i < settings.speed; i++) {
                    update(deltaTime);
                }
                stats.timeElapsed += deltaTime * settings.speed / 60;
            }
            
            render();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // Spawn food periodically
            foodSpawnTimer += deltaTime * settings.foodSpawnRate;
            if (foodSpawnTimer > 30) {
                foodSpawnTimer = 0;
                
                // Spawn based on current food levels
                const oxygenCount = foods.filter(f => f.type === 'oxygen').length;
                const glucoseCount = foods.filter(f => f.type === 'glucose').length;
                const aminoCount = foods.filter(f => f.type === 'amino').length;
                
                if (oxygenCount < 150) spawnFood('oxygen', 3);
                if (glucoseCount < 80) spawnFood('glucose', 2);
                if (aminoCount < 30) spawnFood('amino', 1);
            }
            
            // Update foods
            foods.forEach(food => food.update());
            foods = foods.filter(f => !f.consumed);
            
            // Update organisms
            const newOrganisms = [];
            const newlyDead = [];
            
            organisms.forEach(org => {
                const wasDead = org.dead;
                org.update(deltaTime, foods, organisms);
                
                // Track newly dead organisms
                if (org.dead && !wasDead) {
                    newlyDead.push(org);
                }
                
                // Try to eat
                for (const food of foods) {
                    if (org.tryEat(food)) {
                        food.consumed = true;
                    }
                }
                
                // Try to reproduce
                if (org.canReproduce()) {
                    const child = org.reproduce(settings.mutationRate);
                    if (child) {
                        newOrganisms.push(child);
                    }
                }
            });
            
            // Archive dead organisms for stats
            newlyDead.forEach(org => {
                stats.deadArchive.push({
                    id: org.id,
                    age: org.age,
                    generation: org.generation,
                    offspringCount: org.offspringCount,
                    foodEaten: org.foodEaten,
                    maxEnergy: org.maxEnergy,
                    traits: { ...org.traits },
                    color: { ...org.traits.color }
                });
                
                // Keep archive manageable
                if (stats.deadArchive.length > stats.maxArchiveSize) {
                    stats.deadArchive.shift();
                }
            });
            
            // Remove dead, add new
            organisms = organisms.filter(o => !o.dead);
            organisms.push(...newOrganisms);
            
            // Track peak population
            stats.peakPopulation = Math.max(stats.peakPopulation, organisms.length);
            
            // Record history every 2 seconds of game time
            if (stats.timeElapsed - stats.lastHistoryTime >= 2) {
                stats.lastHistoryTime = stats.timeElapsed;
                
                stats.history.timestamps.push(stats.timeElapsed);
                stats.history.population.push(organisms.length);
                stats.history.births.push(stats.births);
                stats.history.deaths.push(stats.deaths);
                
                // Calculate average traits
                if (organisms.length > 0) {
                    const avgSpeed = organisms.reduce((sum, o) => sum + o.traits.baseSpeed, 0) / organisms.length;
                    const avgSize = organisms.reduce((sum, o) => sum + o.traits.size, 0) / organisms.length;
                    stats.history.avgSpeed.push(avgSpeed);
                    stats.history.avgSize.push(avgSize);
                } else {
                    stats.history.avgSpeed.push(0);
                    stats.history.avgSize.push(0);
                }
                
                // Keep history manageable (last 100 data points)
                if (stats.history.timestamps.length > 100) {
                    stats.history.timestamps.shift();
                    stats.history.population.shift();
                    stats.history.births.shift();
                    stats.history.deaths.shift();
                    stats.history.avgSpeed.shift();
                    stats.history.avgSize.shift();
                }
            }
            
            // Update selected organism reference
            if (selectedOrganism && selectedOrganism.dead) {
                selectedOrganism = null;
            }
        }

        function render() {
            // Clear with lake-like gradient
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 1.5
            );
            gradient.addColorStop(0, '#1a4a4a');
            gradient.addColorStop(0.4, '#0f3535');
            gradient.addColorStop(0.7, '#0a2828');
            gradient.addColorStop(1, '#061e1e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw subtle grid
            ctx.strokeStyle = 'rgba(80, 140, 130, 0.08)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw food
            foods.forEach(food => food.draw(ctx));
            
            // Draw organisms
            organisms.forEach(org => org.draw(ctx));
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateUI() {
            document.getElementById('population').textContent = organisms.length;
            document.getElementById('generation').textContent = stats.maxGeneration;
            document.getElementById('births').textContent = stats.births;
            document.getElementById('deaths').textContent = stats.deaths;
            
            // Food counts
            const oxygenCount = foods.filter(f => f.type === 'oxygen').length;
            const glucoseCount = foods.filter(f => f.type === 'glucose').length;
            const aminoCount = foods.filter(f => f.type === 'amino').length;
            
            document.getElementById('oxygenCount').textContent = oxygenCount;
            document.getElementById('glucoseCount').textContent = glucoseCount;
            document.getElementById('aminoCount').textContent = aminoCount;
            
            document.getElementById('oxygenBar').style.width = Math.min(100, oxygenCount / 1.5) + '%';
            document.getElementById('glucoseBar').style.width = Math.min(100, glucoseCount / 0.8) + '%';
            document.getElementById('aminoBar').style.width = Math.min(100, aminoCount / 0.3) + '%';
            
            // Time
            const minutes = Math.floor(stats.timeElapsed / 60);
            const seconds = Math.floor(stats.timeElapsed % 60);
            document.getElementById('timeElapsed').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Species distribution
            updateSpeciesBar();
            
            // Selected organism info
            updateOrganismInfo();
        }

        function updateSpeciesBar() {
            const speciesCount = {};
            organisms.forEach(org => {
                const sig = org.dna.getSpeciesSignature();
                speciesCount[sig] = (speciesCount[sig] || 0) + 1;
            });
            
            const bar = document.getElementById('speciesBar');
            const legend = document.getElementById('speciesLegend');
            
            bar.innerHTML = '';
            legend.innerHTML = '';
            
            const total = organisms.length || 1;
            const species = Object.entries(speciesCount).sort((a, b) => b[1] - a[1]);
            
            // Show top 5 species + "others" category
            const top5 = species.slice(0, 5);
            const othersCount = species.slice(5).reduce((sum, [_, count]) => sum + count, 0);
            
            let offset = 0;
            top5.forEach(([sig, count], i) => {
                const width = (count / total) * 100;
                const org = organisms.find(o => o.dna.getSpeciesSignature() === sig);
                const color = org ? org.traits.color : { r: 128, g: 128, b: 128 };
                
                const segment = document.createElement('div');
                segment.style.cssText = `
                    position: absolute;
                    left: ${offset}%;
                    width: ${width}%;
                    height: 100%;
                    background: rgba(${color.r}, ${color.g}, ${color.b}, 0.7);
                    transition: all 0.3s;
                `;
                bar.appendChild(segment);
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-dot" style="background: rgb(${color.r}, ${color.g}, ${color.b})"></div>
                    <span>${count}</span>
                `;
                legend.appendChild(legendItem);
                
                offset += width;
            });
            
            // Add "others" segment if there are more species
            if (othersCount > 0) {
                const width = (othersCount / total) * 100;
                const segment = document.createElement('div');
                segment.style.cssText = `
                    position: absolute;
                    left: ${offset}%;
                    width: ${width}%;
                    height: 100%;
                    background: rgba(100, 100, 100, 0.5);
                    transition: all 0.3s;
                `;
                bar.appendChild(segment);
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-dot" style="background: rgb(100, 100, 100)"></div>
                    <span>${othersCount}</span>
                `;
                legend.appendChild(legendItem);
            }
        }

        function updateOrganismInfo() {
            const infoPanel = document.getElementById('organismInfo');
            
            if (!selectedOrganism) {
                infoPanel.classList.remove('active');
                return;
            }
            
            infoPanel.classList.add('active');
            
            const dnaDisplay = document.getElementById('dnaDisplay');
            const traitList = document.getElementById('traitList');
            
            // DNA visualization
            dnaDisplay.innerHTML = '';
            selectedOrganism.dna.chromosomes.forEach((chrom, i) => {
                const avg = chrom.reduce((a, b) => a + b, 0) / chrom.length;
                const hue = (avg / 255) * 120;
                
                const div = document.createElement('div');
                div.className = 'chromosome';
                div.style.background = `hsla(${hue}, 60%, 40%, 0.6)`;
                div.textContent = `C${i + 1}`;
                dnaDisplay.appendChild(div);
            });
            
            // Traits
            const traits = selectedOrganism.traits;
            traitList.innerHTML = `
                <div class="trait-item">
                    <span class="trait-name">Movement</span>
                    <span class="trait-value">${traits.movementType}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Speed</span>
                    <span class="trait-value">${traits.baseSpeed.toFixed(2)} (gene: ${traits.geneticSpeed.toFixed(2)})</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Size</span>
                    <span class="trait-value">${traits.size.toFixed(1)}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Primary Food</span>
                    <span class="trait-value">${traits.primaryFood}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Can Eat</span>
                    <span class="trait-value">${[
                        traits.canEatOxygen ? 'O‚ÇÇ' : '',
                        traits.canEatGlucose ? 'G' : '',
                        traits.canEatAmino ? 'A' : ''
                    ].filter(x => x).join(' ')} (${traits.specialistBonus.toFixed(1)}x)</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Energy</span>
                    <span class="trait-value">${selectedOrganism.energy.toFixed(1)}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Generation</span>
                    <span class="trait-value">${selectedOrganism.generation}</span>
                </div>
                <div class="trait-item">
                    <span class="trait-name">Sensor Range</span>
                    <span class="trait-value">${traits.sensorRange.toFixed(0)}</span>
                </div>
            `;
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Deselect all
            organisms.forEach(o => o.selected = false);
            selectedOrganism = null;
            
            // Find clicked organism
            for (const org of organisms) {
                const dist = Math.sqrt((org.x - x) ** 2 + (org.y - y) ** 2);
                if (dist < org.size + 5) {
                    org.selected = true;
                    selectedOrganism = org;
                    break;
                }
            }
        });

        // Sliders
        document.getElementById('foodRate').addEventListener('input', (e) => {
            settings.foodSpawnRate = parseFloat(e.target.value);
            document.getElementById('foodRateValue').textContent = settings.foodSpawnRate.toFixed(1) + 'x';
        });

        document.getElementById('mutationRate').addEventListener('input', (e) => {
            settings.mutationRate = parseInt(e.target.value) / 100;
            document.getElementById('mutationRateValue').textContent = parseInt(e.target.value) + '%';
        });

        // Speed buttons
        document.getElementById('pauseBtn').addEventListener('click', () => {
            settings.paused = !settings.paused;
            document.getElementById('pauseBtn').textContent = settings.paused ? '‚ñ∂' : '‚è∏';
            document.getElementById('pauseBtn').classList.toggle('active', settings.paused);
        });

        ['speed1', 'speed2', 'speed3'].forEach((id, i) => {
            document.getElementById(id).addEventListener('click', () => {
                settings.speed = [1, 2, 4][i];
                settings.paused = false;
                document.getElementById('pauseBtn').textContent = '‚è∏';
                document.getElementById('pauseBtn').classList.remove('active');
                
                ['speed1', 'speed2', 'speed3'].forEach((sid, si) => {
                    document.getElementById(sid).classList.toggle('active', si === i);
                });
            });
        });

        // Control buttons
        document.getElementById('addOrganisms').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                organisms.push(new Organism(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
        });

        document.getElementById('addFood').addEventListener('click', () => {
            spawnFood('oxygen', 30);
            spawnFood('glucose', 20);
            spawnFood('amino', 10);
        });

        document.getElementById('reset').addEventListener('click', () => {
            organisms = [];
            foods = [];
            stats = {
                births: 0,
                deaths: 0,
                maxGeneration: 1,
                timeElapsed: 0,
                peakPopulation: 0,
                history: {
                    population: [],
                    births: [],
                    deaths: [],
                    timestamps: [],
                    avgSpeed: [],
                    avgSize: []
                },
                lastHistoryTime: 0,
                deadArchive: [],
                maxArchiveSize: 100
            };
            selectedOrganism = null;
            showingStats = false;
            document.getElementById('statsOverlay').classList.remove('active');
            init();
        });

        // Stats overlay handlers
        document.getElementById('showStats').addEventListener('click', () => {
            showingStats = true;
            settings.paused = true;
            document.getElementById('pauseBtn').textContent = '‚ñ∂';
            document.getElementById('pauseBtn').classList.add('active');
            document.getElementById('statsOverlay').classList.add('active');
            renderStatsOverlay();
        });

        document.getElementById('closeStats').addEventListener('click', () => {
            showingStats = false;
            document.getElementById('statsOverlay').classList.remove('active');
        });

        // ============================================
        // STATS OVERLAY RENDERING
        // ============================================

        function renderStatsOverlay() {
            // Update summary stats
            document.getElementById('statTotalBorn').textContent = stats.births;
            document.getElementById('statTotalDied').textContent = stats.deaths;
            document.getElementById('statCurrentPop').textContent = organisms.length;
            document.getElementById('statPeakPop').textContent = stats.peakPopulation;
            
            // Render charts
            renderPopulationChart();
            renderBirthDeathChart();
            renderMovementDistribution();
            renderMetabolismDistribution();
            renderTopOrganisms();
            renderTraitsChart();
            renderGenerationChart();
            renderSizeSpeedChart();
            renderTraitAverages();
        }

        function renderPopulationChart() {
            const canvas = document.getElementById('populationChart');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.parentElement.clientWidth - 20;
            canvas.height = canvas.parentElement.clientHeight - 20;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, w, h);
            
            const data = stats.history.population;
            const timestamps = stats.history.timestamps;
            
            if (data.length < 2) {
                ctx.fillStyle = 'rgba(192, 224, 208, 0.5)';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data yet...', w / 2, h / 2);
                return;
            }
            
            const maxPop = Math.max(...data, 1);
            const minTime = timestamps[0];
            const maxTime = timestamps[timestamps.length - 1];
            
            // Draw axes
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.1)';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (h - 2 * padding) * (1 - i / 4);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(w - padding, y);
                ctx.stroke();
                
                // Y-axis labels
                ctx.fillStyle = 'rgba(192, 224, 208, 0.6)';
                ctx.font = '10px Orbitron';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(maxPop * i / 4), padding - 5, y + 3);
            }
            
            // Draw population line
            ctx.strokeStyle = '#40e0a0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            data.forEach((pop, i) => {
                const x = padding + (timestamps[i] - minTime) / (maxTime - minTime) * (w - 2 * padding);
                const y = h - padding - (pop / maxPop) * (h - 2 * padding);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw area under line
            ctx.lineTo(padding + (w - 2 * padding), h - padding);
            ctx.lineTo(padding, h - padding);
            ctx.closePath();
            ctx.fillStyle = 'rgba(64, 224, 160, 0.1)';
            ctx.fill();
            
            // X-axis label
            ctx.fillStyle = 'rgba(192, 224, 208, 0.6)';
            ctx.font = '10px Rajdhani';
            ctx.textAlign = 'center';
            ctx.fillText('Time (seconds)', w / 2, h - 5);
        }

        function renderBirthDeathChart() {
            const canvas = document.getElementById('birthDeathChart');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.parentElement.clientWidth - 20;
            canvas.height = canvas.parentElement.clientHeight - 20;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, w, h);
            
            const births = stats.history.births;
            const deaths = stats.history.deaths;
            const timestamps = stats.history.timestamps;
            
            if (births.length < 2) {
                ctx.fillStyle = 'rgba(192, 224, 208, 0.5)';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data yet...', w / 2, h / 2);
                return;
            }
            
            // Calculate rates (difference between consecutive values)
            const birthRates = [];
            const deathRates = [];
            for (let i = 1; i < births.length; i++) {
                birthRates.push(births[i] - births[i-1]);
                deathRates.push(deaths[i] - deaths[i-1]);
            }
            
            const maxRate = Math.max(...birthRates, ...deathRates, 1);
            const minTime = timestamps[1];
            const maxTime = timestamps[timestamps.length - 1];
            
            // Draw axes
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();
            
            // Draw birth line (green)
            ctx.strokeStyle = '#60ffc0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            birthRates.forEach((rate, i) => {
                const x = padding + (timestamps[i + 1] - minTime) / (maxTime - minTime) * (w - 2 * padding);
                const y = h - padding - (rate / maxRate) * (h - 2 * padding);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw death line (red)
            ctx.strokeStyle = '#ff6060';
            ctx.lineWidth = 2;
            ctx.beginPath();
            deathRates.forEach((rate, i) => {
                const x = padding + (timestamps[i + 1] - minTime) / (maxTime - minTime) * (w - 2 * padding);
                const y = h - padding - (rate / maxRate) * (h - 2 * padding);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '11px Rajdhani';
            ctx.fillStyle = '#60ffc0';
            ctx.fillRect(w - 100, 10, 12, 12);
            ctx.fillText('Births', w - 82, 20);
            ctx.fillStyle = '#ff6060';
            ctx.fillRect(w - 100, 28, 12, 12);
            ctx.fillText('Deaths', w - 82, 38);
        }

        function renderMovementDistribution() {
            const container = document.getElementById('movementDistribution');
            
            // Count movement types from alive organisms
            const counts = { none: 0, cilia: 0, flagellum: 0, pseudopod: 0 };
            organisms.forEach(org => {
                counts[org.traits.movementType]++;
            });
            
            const total = organisms.length || 1;
            const colors = {
                none: '#888888',
                cilia: '#60c0ff',
                flagellum: '#ff60c0',
                pseudopod: '#c0ff60'
            };
            
            let html = '<div class="distribution-bar">';
            for (const [type, count] of Object.entries(counts)) {
                const pct = (count / total) * 100;
                if (pct > 0) {
                    html += `<div class="distribution-segment" style="width: ${pct}%; background: ${colors[type]}">${pct > 10 ? Math.round(pct) + '%' : ''}</div>`;
                }
            }
            html += '</div><div class="distribution-legend">';
            for (const [type, count] of Object.entries(counts)) {
                html += `<div class="distribution-legend-item">
                    <div class="distribution-legend-dot" style="background: ${colors[type]}"></div>
                    <span>${type}: ${count}</span>
                </div>`;
            }
            html += '</div>';
            
            container.innerHTML = html;
        }

        function renderMetabolismDistribution() {
            const container = document.getElementById('metabolismDistribution');
            
            // Count what organisms can eat
            const counts = { oxygen: 0, glucose: 0, amino: 0 };
            organisms.forEach(org => {
                if (org.traits.canEatOxygen) counts.oxygen++;
                if (org.traits.canEatGlucose) counts.glucose++;
                if (org.traits.canEatAmino) counts.amino++;
            });
            
            const total = organisms.length || 1;
            const colors = {
                oxygen: '#4080ff',
                glucose: '#ffc040',
                amino: '#ff60b0'
            };
            const labels = {
                oxygen: 'O‚ÇÇ',
                glucose: 'Glucose',
                amino: 'Amino'
            };
            
            let html = '<div class="distribution-bar">';
            const grandTotal = counts.oxygen + counts.glucose + counts.amino || 1;
            for (const [type, count] of Object.entries(counts)) {
                const pct = (count / grandTotal) * 100;
                if (pct > 0) {
                    html += `<div class="distribution-segment" style="width: ${pct}%; background: ${colors[type]}">${pct > 10 ? Math.round(pct) + '%' : ''}</div>`;
                }
            }
            html += '</div><div class="distribution-legend">';
            for (const [type, count] of Object.entries(counts)) {
                const pct = Math.round((count / total) * 100);
                html += `<div class="distribution-legend-item">
                    <div class="distribution-legend-dot" style="background: ${colors[type]}"></div>
                    <span>${labels[type]}: ${count} (${pct}%)</span>
                </div>`;
            }
            html += '</div>';
            
            container.innerHTML = html;
        }

        function renderTopOrganisms() {
            // Combine living and dead organisms for analysis
            const allOrganisms = [
                ...organisms.map(o => ({
                    age: o.age,
                    generation: o.generation,
                    offspringCount: o.offspringCount,
                    foodEaten: o.foodEaten,
                    traits: o.traits,
                    color: o.traits.color,
                    alive: true
                })),
                ...stats.deadArchive.map(o => ({ ...o, alive: false }))
            ];
            
            // Longest lived
            const longestLived = [...allOrganisms]
                .sort((a, b) => b.age - a.age)
                .slice(0, 5);
            
            const longestList = document.getElementById('longestLivedList');
            if (longestLived.length === 0 || longestLived[0].age < 1) {
                longestList.innerHTML = '<div class="no-data-message">No significant data yet</div>';
            } else {
                longestList.innerHTML = longestLived.map((org, i) => `
                    <div class="top-organism-item">
                        <div class="organism-rank">#${i + 1}</div>
                        <div class="organism-color-dot" style="background: rgb(${org.color.r}, ${org.color.g}, ${org.color.b})"></div>
                        <div class="organism-details">
                            <div class="organism-stat-name">Lived ${(org.age / 60).toFixed(1)}s ${org.alive ? '(alive)' : ''}</div>
                            <div class="organism-stat-value">Gen ${org.generation} | ${org.traits.movementType} | ${org.offspringCount} offspring</div>
                        </div>
                    </div>
                `).join('');
            }
            
            // Most offspring
            const mostOffspring = [...allOrganisms]
                .sort((a, b) => b.offspringCount - a.offspringCount)
                .slice(0, 5);
            
            const offspringList = document.getElementById('mostOffspringList');
            if (mostOffspring.length === 0 || mostOffspring[0].offspringCount === 0) {
                offspringList.innerHTML = '<div class="no-data-message">No reproductions yet</div>';
            } else {
                offspringList.innerHTML = mostOffspring.map((org, i) => `
                    <div class="top-organism-item">
                        <div class="organism-rank">#${i + 1}</div>
                        <div class="organism-color-dot" style="background: rgb(${org.color.r}, ${org.color.g}, ${org.color.b})"></div>
                        <div class="organism-details">
                            <div class="organism-stat-name">${org.offspringCount} offspring ${org.alive ? '(alive)' : ''}</div>
                            <div class="organism-stat-value">Gen ${org.generation} | ${org.traits.movementType} | ${org.foodEaten} food eaten</div>
                        </div>
                    </div>
                `).join('');
            }
        }

        function renderTraitsChart() {
            const canvas = document.getElementById('traitsChart');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.parentElement.clientWidth - 20;
            canvas.height = canvas.parentElement.clientHeight - 20;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, w, h);
            
            const speeds = stats.history.avgSpeed;
            const sizes = stats.history.avgSize;
            const timestamps = stats.history.timestamps;
            
            if (speeds.length < 2) {
                ctx.fillStyle = 'rgba(192, 224, 208, 0.5)';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data yet...', w / 2, h / 2);
                return;
            }
            
            const maxSpeed = Math.max(...speeds.filter(s => s > 0), 1);
            const maxSize = Math.max(...sizes.filter(s => s > 0), 1);
            const minTime = timestamps[0];
            const maxTime = timestamps[timestamps.length - 1];
            
            // Draw axes
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();
            
            // Draw speed line (normalized)
            ctx.strokeStyle = '#ff9040';
            ctx.lineWidth = 2;
            ctx.beginPath();
            speeds.forEach((speed, i) => {
                if (speed === 0) return;
                const x = padding + (timestamps[i] - minTime) / (maxTime - minTime) * (w - 2 * padding);
                const y = h - padding - (speed / maxSpeed) * (h - 2 * padding);
                if (i === 0 || speeds[i-1] === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw size line (normalized)
            ctx.strokeStyle = '#40c0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            sizes.forEach((size, i) => {
                if (size === 0) return;
                const x = padding + (timestamps[i] - minTime) / (maxTime - minTime) * (w - 2 * padding);
                const y = h - padding - (size / maxSize) * (h - 2 * padding);
                if (i === 0 || sizes[i-1] === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '11px Rajdhani';
            ctx.fillStyle = '#ff9040';
            ctx.fillRect(w - 120, 10, 12, 12);
            ctx.fillText('Avg Speed', w - 102, 20);
            ctx.fillStyle = '#40c0ff';
            ctx.fillRect(w - 120, 28, 12, 12);
            ctx.fillText('Avg Size', w - 102, 38);
        }

        function renderGenerationChart() {
            const canvas = document.getElementById('generationChart');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.parentElement.clientWidth - 20;
            canvas.height = canvas.parentElement.clientHeight - 20;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, w, h);
            
            if (organisms.length === 0) {
                ctx.fillStyle = 'rgba(192, 224, 208, 0.5)';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('No organisms alive', w / 2, h / 2);
                return;
            }
            
            // Count generations
            const genCounts = {};
            organisms.forEach(org => {
                genCounts[org.generation] = (genCounts[org.generation] || 0) + 1;
            });
            
            const generations = Object.keys(genCounts).map(Number).sort((a, b) => a - b);
            const maxCount = Math.max(...Object.values(genCounts));
            
            if (generations.length === 0) return;
            
            const barWidth = Math.min(30, (w - 2 * padding) / generations.length - 5);
            const totalWidth = generations.length * (barWidth + 5);
            const startX = (w - totalWidth) / 2;
            
            // Draw bars
            generations.forEach((gen, i) => {
                const count = genCounts[gen];
                const barHeight = (count / maxCount) * (h - 2 * padding - 20);
                const x = startX + i * (barWidth + 5);
                const y = h - padding - barHeight;
                
                // Bar gradient
                const gradient = ctx.createLinearGradient(x, y, x, h - padding);
                gradient.addColorStop(0, '#40e0a0');
                gradient.addColorStop(1, '#20a070');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Generation label
                ctx.fillStyle = 'rgba(192, 224, 208, 0.8)';
                ctx.font = '10px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(gen, x + barWidth / 2, h - padding + 15);
                
                // Count label
                ctx.fillStyle = '#60ffc0';
                ctx.fillText(count, x + barWidth / 2, y - 5);
            });
            
            // X-axis label
            ctx.fillStyle = 'rgba(192, 224, 208, 0.6)';
            ctx.font = '10px Rajdhani';
            ctx.textAlign = 'center';
            ctx.fillText('Generation', w / 2, h - 5);
        }

        function renderSizeSpeedChart() {
            const canvas = document.getElementById('sizeSpeedChart');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.parentElement.clientWidth - 20;
            canvas.height = canvas.parentElement.clientHeight - 20;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, w, h);
            
            if (organisms.length === 0) {
                ctx.fillStyle = 'rgba(192, 224, 208, 0.5)';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('No organisms alive', w / 2, h / 2);
                return;
            }
            
            const minSize = 5, maxSize = 40;
            const minSpeed = 0.04, maxSpeed = 4;
            
            // Draw axes
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = 'rgba(192, 224, 208, 0.6)';
            ctx.font = '10px Rajdhani';
            ctx.textAlign = 'center';
            ctx.fillText('Size ‚Üí', w / 2, h - 5);
            
            ctx.save();
            ctx.translate(10, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Speed ‚Üí', 0, 0);
            ctx.restore();
            
            // Plot organisms
            organisms.forEach(org => {
                const x = padding + ((org.traits.size - minSize) / (maxSize - minSize)) * (w - 2 * padding);
                const y = h - padding - ((org.traits.baseSpeed - minSpeed) / (maxSpeed - minSpeed)) * (h - 2 * padding);
                
                // Draw point with organism's color
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${org.traits.color.r}, ${org.traits.color.g}, ${org.traits.color.b}, 0.7)`;
                ctx.fill();
                ctx.strokeStyle = `rgba(${org.traits.color.r}, ${org.traits.color.g}, ${org.traits.color.b}, 1)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function renderTraitAverages() {
            const container = document.getElementById('traitAverages');
            
            if (organisms.length === 0) {
                container.innerHTML = '<div class="no-data-message">No organisms alive</div>';
                return;
            }
            
            // Calculate averages
            const avgSize = organisms.reduce((s, o) => s + o.traits.size, 0) / organisms.length;
            const avgSpeed = organisms.reduce((s, o) => s + o.traits.baseSpeed, 0) / organisms.length;
            const avgGeneticSpeed = organisms.reduce((s, o) => s + o.traits.geneticSpeed, 0) / organisms.length;
            const avgMetabolicRate = organisms.reduce((s, o) => s + o.traits.metabolicRate, 0) / organisms.length;
            const avgSensorRange = organisms.reduce((s, o) => s + o.traits.sensorRange, 0) / organisms.length;
            const avgReproThreshold = organisms.reduce((s, o) => s + o.traits.reproductionThreshold, 0) / organisms.length;
            const avgSpecialistBonus = organisms.reduce((s, o) => s + o.traits.specialistBonus, 0) / organisms.length;
            
            const traits = [
                { name: 'Size', value: avgSize, min: 5, max: 40, color: '#40c0ff' },
                { name: 'Genetic Speed', value: avgGeneticSpeed, min: 0.1, max: 4.0, color: '#ff9040' },
                { name: 'Actual Speed', value: avgSpeed, min: 0.04, max: 4.0, color: '#ffb060' },
                { name: 'Metabolic Rate', value: avgMetabolicRate, min: 0.2, max: 2.0, color: '#ffc040' },
                { name: 'Sensor Range', value: avgSensorRange, min: 15, max: 250, color: '#c040ff' },
                { name: 'Specialist Bonus', value: avgSpecialistBonus, min: 1.0, max: 1.8, color: '#40ffc0' }
            ];
            
            let html = '<div class="trait-avg-grid">';
            traits.forEach(trait => {
                const pct = ((trait.value - trait.min) / (trait.max - trait.min)) * 100;
                const displayValue = trait.value < 1 ? trait.value.toFixed(2) : trait.value.toFixed(1);
                html += `
                    <div class="trait-avg-item">
                        <div class="trait-avg-header">
                            <span class="trait-avg-name">${trait.name}</span>
                            <span class="trait-avg-value">${displayValue}</span>
                        </div>
                        <div class="trait-avg-bar-bg">
                            <div class="trait-avg-bar-fill" style="width: ${Math.min(100, Math.max(0, pct))}%; background: ${trait.color}"></div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }

        // ============================================
        // START
        // ============================================

        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
